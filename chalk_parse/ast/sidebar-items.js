initSidebarItems({"enum":[["DomainGoal",""],["FloatTy",""],["Goal",""],["ImplType",""],["InlineBound","An inline bound, e.g. `: Foo<K>` in `impl<K, T: Foo<K>> SomeType<T>`."],["IntTy",""],["Item",""],["Kind",""],["LeafGoal",""],["Lifetime",""],["Parameter",""],["ParameterKind",""],["Polarity",""],["ScalarType",""],["Ty",""],["UintTy",""],["WellKnownTrait",""],["WhereClause",""]],"struct":[["AliasEqBound","Represents an alias equality bound on e.g. a type or type parameter. Does not know anything about what it's binding."],["AssocTyDefn",""],["AssocTyValue",""],["Clause","This allows users to add arbitrary `A :- B` clauses into the logic; it has no equivalent in Rust, but it's useful for testing."],["Field",""],["Identifier",""],["Impl",""],["OpaqueTyDefn",""],["Program",""],["ProjectionTy",""],["QuantifiedInlineBound",""],["QuantifiedWhereClause",""],["Span",""],["StructDefn",""],["StructFlags",""],["TraitBound","Represents a trait bound on e.g. a type or type parameter. Does not know anything about what it's binding."],["TraitDefn",""],["TraitFlags",""],["TraitRef",""]]});